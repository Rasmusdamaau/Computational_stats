---
title: "SS_1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```



Exercise 2.

Parameters:

$$  \lambda = x = \bar{\sigma} = T = 1. $$

### 1, 2

By Using a Riemann approximation of $ \int_0^t Z_s ds$, write a code that simulates (with error) the exact solution of $(1)$ (i.e. (2)) on an equally spaced grid of $[0,1]$ given by

$$t_k = \frac{k}{n}, \quad k = 0, \ldots, n, \quad n \in \mathbb{N}.$$


Plot simulated paths for $n = 10000$.


```{r}
n <- 10000
set.seed(1)


sim_BM <- function(T_, delta) {
  tmesh <- seq(from = 0, to = T_, by = delta)
  N <- length(tmesh)
  step <- delta * T_
  Norm <- rnorm(N)
  B <- c(0, cumsum(sqrt(step) * Norm[-N]))
  output <- data.frame(B = B, Norm = Norm)
  return(output)
}


b <- function(t, X_t, B) {
  exp(0.5 * t + B)
}
sim_BM_result <- sim_BM(1, 1/n)

approx_integral_exact_solution <- function(delta, T_ = 1, b, sigma, x_0 = 0) {
  N_n <- ceiling(T_ / delta)
  tmesh <- seq(from = 0, to = T_, by = delta)
  #sim_BM_result <- sim_BM(T_, delta)
  B <- sim_BM_result$B
  X <- c(x_0)
  step <- delta * T_
  for (k in 2:(N_n + 1)) {
    X[k] <- X[k - 1] + b(tmesh[k], X[k - 1], B[k - 1]) * step
  }
  XX <- b(t = tmesh, X_t = 0, B = B) / (1 + X)
  output <- data.frame(real_sol =XX, sim_sol=X)
  return(output)
}

ZZ <- approx_integral_exact_solution(
  delta = 1 / n,
  T_ = 1,
  b = b,
  sigma = sigma,
  x_0 = 1
)

ggplot(data = ZZ, aes(x=seq_len(nrow(ZZ)), y = sim_sol)) +
  geom_line(color = "red") +
  geom_line(aes(x=seq_len(nrow(ZZ)), y = real_sol))


```

### 3

Approximate (1) with Euler Scheme


```{r}


b <- function(t, X_t) {
  X_t - X_t^2
}

sigma <- function(t, X_t) {
  X_t
}

Euler_scheme <- function(delta, T_ = 1, b, sigma, x_0 = 0) {
  N_n <- ceiling(T_ / delta)
  tmesh <- seq(from = 0, to = T_, by = delta)
  #sim_BM_result <- sim_BM(T_, delta)
  B <- sim_BM_result$B
  X <- c(x_0)
  X1 <- c(0)
  step <- delta * T_
  for (k in 2:(N_n+1)) {
    X[k] <- X[k-1] + b(tmesh[k-1],X[k-1])*step + sigma(tmesh[k-1],X[k-1])*(B[k] - B[k-1])
    X1[k] <- X1[k - 1] + exp(0.5 * tmesh[k] + B[k-1]) * step
  }
  XX <- exp(0.5 * tmesh + B) / (1 + X1)
  output <- data.frame(real_sol =XX, sim_sol=X)
  return(output)
}

XX_sim <- Euler_scheme(delta = 1/n, T_ = 1,b = b,sigma = sigma,x_0 = 1)

ggplot(data = XX_sim, aes(x=seq_len(nrow(XX_sim)), y = sim_sol)) +
  geom_line(color = "blue") +
  geom_line(aes(x=seq_len(nrow(XX_sim)), y = real_sol), color = "green") 
norm(as.matrix(XX_sim[,1]-XX_sim[,2]), type="F")
plot.ts(XX_sim[,1]-XX_sim[,2])

```




```{r}
b <- function(t, X_t) {
  X_t - X_t^2
}

sigma <- function(t, X_t) {
  X_t
}


msigma <- function(t, X_t) {
  1
}


Milstein_scheme <- function(delta, T_ = 1, b, sigma, msigma, x_0 = 0) {
  N_n <- ceiling(T_ / delta)
  tmesh <- seq(from = 0, to = T_, by = delta)
  #sim_BM_result <- sim_BM(T_, delta)
  B <- sim_BM_result$B
  Norm <- sim_BM_result$Norm
  X <- c(x_0)
  X1 <- c(0)
  step <- delta * T_
  for (k in 2:(N_n+1)) {
    X[k] <- X[k-1] + b(k,X[k-1])*step + sigma(k,X[k-1])*(B[k] - B[k-1])+
      1/2*sigma(k,X[k-1])*msigma(k, X[k-1])*((B[k]-B[k-1])^2-step)
    X1[k] <- X1[k - 1] + exp(0.5 * tmesh[k] + B[k-1]) * step
  }
  XX <- exp(0.5 * tmesh + B) / (1 + X1)
  output <- data.frame(sim_sol = X, real_sol = XX)
  return(output)
}

XX_sim1 <- Milstein_scheme(delta = 1/n, T_ = 1,b = b,sigma = sigma, msigma = msigma,x_0 = 1)


ggplot(data = XX_sim1, aes(x=seq_len(nrow(XX_sim1)), y = sim_sol)) +
  geom_line(color = "black") +
  geom_line(aes(x=seq_len(nrow(XX_sim1)), y = real_sol), color = "yellow") 

norm(as.matrix(XX_sim1[,1]-XX_sim1[,2]), type="F")
plot.ts(XX_sim1[,1]-XX_sim1[,2])
```


```{r}
for (n in c(10,100,1000)){
sim_BM_result <- sim_BM(1, 1/n)
XX_sim <- Euler_scheme(delta = 1/n, T_ = 1,b = b,sigma = sigma,x_0 = 1)
XX_sim1 <- Milstein_scheme(delta = 1/n, T_ = 1,b = b,sigma = sigma, msigma = msigma,x_0 = 1)

par(mfrow = c(3,1))
plot.ts(XX_sim[,1])
plot.ts(XX_sim[,2])
plot.ts(XX_sim1[,1])

}
```

