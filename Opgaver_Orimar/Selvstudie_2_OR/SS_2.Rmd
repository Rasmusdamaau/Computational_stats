---
title: "miniprojekt_2"
output:
  pdf_document:
    extra_dependencies: ["float"]
    toc: true
    toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(language = "en")
# library(sde)
library(tidyverse)
```

# Exercise 1.

## 1.

```{r}

sim_BM <- function(T_, delta) {
  if (delta == 0) {
    return(0)
  } else {
    tmesh <- seq(from = 0, to = T_, by = delta)
  }
  N <- length(tmesh) %>% ceiling()
  Norm <- rnorm(N)
  B <- c(0, cumsum(sqrt(delta) * Norm[-N]))
  return(B)
}

b <- function(x) {
  matrix(c(
    0,
    0.5 - (0.5 + 0) * x[2]
  ), nrow = 2, ncol = 1)
}

sigma <- function(x) {
  matrix(c(
    x[1] * sqrt(1),
    0, 0, 0.4
  ), nrow = 2, ncol = 2) * sqrt(x[2])
}

payoff <- function(x, K) {
  if (is.vector(x)) {
    return(max(x[2] - K, 0))
  } else {
    return(max(x[, 1] - K, 0))
  }
}

algo_1 <- function(M, n, t, T, r, b, sigma, x, payoff, K) {
  if (T - t < 0.0001) {
    return(payoff(x, K))
  } else {
    delta_n <- (T - t) / n
  }
  # print(delta_n)
  last_obs <- matrix(NA, nrow = M, ncol = 2)
  for (j in 1:M) {
    bm1 <- diff(sim_BM(T_ = T, delta = delta_n))
    bm2 <- diff(sim_BM(T_ = T, delta = delta_n))
    bm <- cbind(bm1, bm2)
    X <- matrix(NA, nrow = n + 2, ncol = 2, byrow = TRUE)
    X[1, ] <- x
    for (k in 1:n) {
      # print(delta_n * b(X[k, ]))
      # print(sigma(X[k, ]) %*% bm[k, ])
      # print(n)
      # print(k)
      X[k + 1, ] <- X[k, ] + delta_n * b(X[k, ]) + sigma(X[k, ]) %*% bm[k, ]
    }
    last_obs[j, ] <- X[n + 1, ]
  }
  F <- exp(-r * (T - t)) * 1 / M * sum(payoff(last_obs, K))
  return(F)
}

# algo_1(M = 100, n = 100, t = 0.1, T = 1, r = 0.1, b = b, sigma = sigma, x = c(9, 0.1), payoff = payoff, K = 10)


Heston_euler_payoff <- function(n_, m_, q_, x_min, x_max, v_min, v_max, T, K) {
  delta_n_time <- T / n_
  delta_m_price <- (x_max - x_min) / m_
  delta_q_vol <- (v_max - v_min) / q_
  t <- delta_n_time * 0:n_
  x <- x_min + 0:m_ * delta_m_price
  v <- v_min + delta_q_vol * 0:q_

  result <- matrix(
    data = NA, nrow = (n_ + 1) * (m_ + 1) * (q_ + 1),
    ncol = 4, dimnames = list(c(), c("t", "si", "y", "price"))
  )
  i <- 1
  for (t_ in t) {
    for (si_ in x) {
      for (y_ in v) {
        result[i, c("t", "si", "y", "price")] <- c(
          t_, si_, y_,
          algo_1(
            M = 10, # monte carlo sims
            n = n_ * (T - t_),
            t = t_, T = T, r = 0, b = b, sigma = sigma, x = c(si_, y_), payoff = payoff, K = K
          )
        )
        i <- i + 1
      }
    }
  }
  return(result)
}
```

## 2.

```{r}
ex_2 <- Heston_euler_payoff(
  n_ = 100, m_ = 10, q_ = 10,
  x_min = 0, x_max = 10, v_min = 0,
  v_max = 10, T = 1, K = 1
)
```

## 3.

```{r}

```

## 4.

```{r}

```


## 5.



```{r}

G <- function(tau, x, v, K, x_max, v_max) {
  return(
    case_when(tau == 0 ~ max(x - K, 0),
              x == 0 ~ 0,
              x == x_max ~ x_max,
              v == 0 ~ max(x - 1, K),
              v == v_max ~ x)
    )
}

G_price <- function(df,t_,x_,v_) {
  df %>% dplyr::filter(t == t_,
                       x == x_,
                       v == v_) %>% pull(price)
}

finite_difference_approx <- function(n_, m_, q_, x_min, x_max, v_min, v_max, T, K) {
  delta_n_time <- T / n_
  delta_m_price <- (x_max - x_min) / m_
  delta_q_vol <- (v_max - v_min) / q_
  t <- delta_n_time * 0:n_
  x <- x_min + 0:m_ * delta_m_price
  v <- v_min + delta_q_vol * 0:q_
  
  result <- matrix(
    data = NA, nrow = (n_ + 1) * (m_ + 1) * (q_ + 1),
    ncol = 4, dimnames = list(c(), c("t", "x", "v", "price"))
  )
  
  i <- 1
  for (t_ in t) {
    for (si_ in x) {
      for (y_ in v) {
        result[i, c("t", "x", "v", "price")] <- c(
          t_, si_, y_,
          NA
        )
        i <- i + 1
      }
    }
  }
  
  result_df <- result %>%
    as_tibble() %>%
    rowwise() %>% 
    mutate(price = G(tau = t,x = x,v = v,K = K,x_max = x_max,v_max = v_max)) %>%
    ungroup()
  
  for (i in 1:nrow(result_df)) {
    if (is.na(result_df[i,"price"])) {
      t_x_v_i <- result_df[i,c("t", "x", "v")]
      
      t_i <- t[(which(t_x_v_i$t == t) - 1)]
      x_i <- t_x_v_i$x
      v_i <- t_x_v_i$v
      
      d_v <- (G_price(result_df, t_i, x_i, v_i + delta_q_vol) -
        G_price(result_df, t_i,x_i, v_i)) * delta_q_vol
      
      d_xx <- (G_price(result_df, t_i, x_i + delta_m_price, v_i) - 
                 2 * G_price(result_df, t_i, x_i, v_i) +
                 G_price(result_df, t_i, x_i - delta_m_price, v_i)) / (delta_m_price^2)      
      
      d_vv <- (G_price(result_df, t_i, x_i, v_i + delta_q_vol) -
                 2 * G_price(result_df, t_i, x_i, v_i) +
                 G_price(result_df, t_i, x_i, v_i - delta_q_vol)) / (delta_q_vol^2)
      
      d_xv <- (G_price(result_df, t_i, x_i + delta_m_price, v_i + delta_q_vol) -
                 G_price(result_df, t_i, x_i, v_i) +
                 G_price(result_df, t_i, x_i - delta_m_price, v_i - delta_q_vol)) / 
        (delta_m_price * delta_q_vol)
      
      result_df[i, "price"] <- G_price(result_df, t_i, x_i, v_i) + delta_n_time * (
        (0.5 + 0.5 * v_i) * d_v + (1/2) * (x_i^2) * v_i * d_xx + (1/2) * (0.4^2) * v_i * d_vv -
          0.7 * 0.4 * v_i * x_i * d_xv
      )
    }
  }
  
  return(result_df)
  
}





```


## 6.

```{r}

ex_6 <- finite_difference_approx(n_ = 100, m_ = 10, q_ = 10,
  x_min = 0, x_max = 10, v_min = 0,
  v_max = 10, T = 1, K = 1)


```


## 7.

```{r}
plot_data <- ex_6 %>% mutate(t = 1 - t,
                             metode = "finite_difference") %>% 
  union(., ex_2 %>% as_tibble() %>% 
               mutate(metode = "monte_carlo") %>% 
               rename(x = si,
                      v = y))

plot_difference <- ggplot(data = plot_data) +
  coord_cartesian(ylim = c(-2,20))

plot_difference + geom_point(aes(x = x, y = price, color = metode))
plot_difference + geom_point(aes(x = v, y = price, color = metode))
plot_difference + geom_point(aes(x = t, y = price, color = metode))

```


## 8.


# Exercise 2.

## 1.

```{r}

```


## 2.

```{r}

```


## 3.

```{r}

```
