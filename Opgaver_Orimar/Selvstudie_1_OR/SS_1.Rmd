---
title: "SS_1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## Exercise 2.

Parameters:

$$  \lambda = x = \bar{\sigma} = T = 1. $$

### 1, 2

By Using a Riemann approximation of $ \int_0^t Z_s ds$, write a code that simulates (with error) the exact solution of $(1)$ (i.e. (2)) on an equally spaced grid of $[0,1]$ given by

$$t_k = \frac{k}{n}, \quad k = 0, \ldots, n, \quad n \in \mathbb{N}.$$


Plot simulated paths for $n = 10000$.


```{r}

set.seed(1)


sim_BM <- function(T_, delta) {
  tmesh <- seq(from = 0, to = T_, by = delta)
  N <- length(tmesh)
  step <- delta * T_
  Norm <- rnorm(N)
  B <- c(0, cumsum(sqrt(step) * Norm[-N]))
  output <- data.frame(B = B, Norm = Norm)
  return(output)
}

Z_t <- function(t, B) {
  exp(0.5 * t + B)
}

b <- function(t, X_t) {
  X_t - X_t^2
}

sigma <- function(t, X_t) {
  X_t
}

sigma_dif <- function(t, X_t) {
  1
}

approx_integral_exact_solution_Euler_sol_Milstein_sol <- function(delta, T_ = 1, b, sigma, x_0 = 0, Z_t, sigma_dif) {
  N_n <- ceiling(T_ / delta)
  tmesh <- seq(from = 0, to = T_, by = delta)
  sim_BM_result <- sim_BM(T_, delta)
  B <- sim_BM_result$B
  X <- c(0)
  X_2 <- c(x_0)
  X_3 <- c(x_0)
  step <- delta * T_
  for (k in 2:(N_n + 1)) {
    # Approximate integral
    X[k] <- X[k - 1] + Z_t(tmesh[k], B[k - 1]) * step
    # Euler scheme
    X_2[k] <- X_2[k - 1] + b(tmesh[k], X_2[k - 1]) * step +
      sigma(tmesh[k], X_2[k - 1]) * (B[k] - B[k - 1])
    # Milstein scheme
    X_3[k] <- X_3[k - 1] + b(tmesh[k], X_3[k - 1]) * step + sigma(tmesh[k], X_3[k - 1]) * (B[k] - B[k - 1]) +
      1 / 2 * sigma(tmesh[k - 1], X_3[k - 1]) * sigma_dif(tmesh[k - 1], X_3[k - 1]) * ((B[k] - B[k - 1])^2 - step)
  }

  XX <- Z_t(t = tmesh, B = B) / (1 + X)
  output <- data.frame(
    exact = XX,
    euler = X_2,
    milstein = X_3
  )
  return(output)
}

plot_sde <- function(n) {
  XX <- approx_integral_exact_solution_Euler_sol_Milstein_sol(
    delta = 1 / n,
    T_ = 1,
    b = b,
    sigma = sigma,
    x_0 = 1,
    Z_t = Z_t,
    sigma_dif = sigma_dif
  )
  par(mfrow = c(3, 1))
  plot.ts(XX$exact)
  plot.ts(XX$euler)
  plot.ts(XX$milstein)
}
plot_sde(1000)


# XX <- approx_integral_exact_solution_Euler_sol_Milstein_sol(
#   delta = 1 / 10000,
#   T_ = 1,
#   b = b,
#   sigma = sigma,
#   x_0 = 1,
#   Z_t = Z_t,
#   sigma_dif = sigma_dif
# )
#
# par(mfrow = c(3,1))
# plot.ts(XX$exact)
# plot.ts(XX$euler)
# plot.ts(XX$milstein)
```
